# Gocrete Examples

This directory contains examples of projects generated by Gocrete and demonstrates various use cases.

## Example 1: Simple REST API

```bash
gocrete init simple-api \
  --module github.com/example/simple-api \
  --router chi
```

**Generated Structure:**
```
simple-api/
├── cmd/server/main.go          # Entry point with graceful shutdown
├── internal/
│   ├── config/config.go        # Environment-based configuration
│   ├── logger/logger.go        # Structured JSON logging
│   ├── http/server.go          # Chi router with middleware
│   └── errors/errors.go        # Error response helpers
├── .gitignore
├── .env.example
├── go.mod
└── README.md
```

**Features:**
- Health check endpoints (`/health`, `/ready`)
- Request ID middleware
- Structured logging
- Panic recovery
- Environment configuration

**Run:**
```bash
cd simple-api
go mod download
go run cmd/server/main.go
```

**Test:**
```bash
curl http://localhost:8080/health
# {"status":"healthy"}
```

---

## Example 2: PostgreSQL-backed API

```bash
gocrete init user-api \
  --module github.com/example/user-api \
  --router chi \
  --db postgres \
  --migrations goose \
  --docker
```

**Generated Structure:**
```
user-api/
├── cmd/server/main.go
├── internal/
│   ├── config/config.go         # Includes DATABASE_URL
│   ├── logger/logger.go
│   ├── http/server.go
│   ├── errors/errors.go
│   └── db/postgres/
│       ├── postgres.go          # pgx connection pool
│       └── repository.go        # Example user repository
├── migrations/
│   ├── .gitkeep
│   └── 00001_initial.sql        # Initial migration
├── docker-compose.yml           # PostgreSQL service
├── Dockerfile
├── .gitignore
├── .env.example
├── go.mod
└── README.md
```

**Database Features:**
- pgx v5 connection pool
- Optimized pool settings (25 max, 5 min connections)
- Repository pattern with CRUD operations
- Context-aware queries
- Transaction support ready
- Goose migrations

**Development Workflow:**

1. **Start Database:**
   ```bash
   docker-compose up -d postgres
   ```

2. **Run Migrations:**
   ```bash
   goose -dir migrations postgres "postgres://postgres:postgres@localhost:5432/user_api?sslmode=disable" up
   ```

3. **Start Server:**
   ```bash
   export DATABASE_URL="postgres://postgres:postgres@localhost:5432/user_api?sslmode=disable"
   go run cmd/server/main.go
   ```

**Repository Example:**
```go
// internal/db/postgres/repository.go provides:

// Get user by ID
user, err := repo.GetByID(ctx, 1)

// List all users
users, err := repo.List(ctx)

// Create user
user, err := repo.Create(ctx, "user@example.com")

// Update user
err = repo.Update(ctx, 1, "newemail@example.com")

// Delete user
err = repo.Delete(ctx, 1)
```

---

## Example 3: MongoDB Microservice

```bash
gocrete init product-service \
  --module github.com/example/product-service \
  --router fiber \
  --db mongo \
  --docker
```

**Generated Structure:**
```
product-service/
├── cmd/server/main.go
├── internal/
│   ├── config/config.go         # Includes MONGO_URL, MONGO_DB
│   ├── logger/logger.go
│   ├── http/server.go          # Fiber router
│   ├── errors/errors.go
│   └── db/mongo/
│       ├── mongo.go             # MongoDB client
│       └── repository.go        # Example repository
├── docker-compose.yml           # MongoDB service
├── Dockerfile
├── .gitignore
└── README.md
```

**MongoDB Features:**
- Official mongo-driver
- Collection-based repositories
- BSON/ObjectID support
- Aggregation pipeline ready
- Context-aware operations

**Development Workflow:**

1. **Start MongoDB:**
   ```bash
   docker-compose up -d mongo
   ```

2. **Start Server:**
   ```bash
   export MONGO_URL="mongodb://localhost:27017"
   export MONGO_DB="product_service"
   go run cmd/server/main.go
   ```

**Repository Example:**
```go
// internal/db/mongo/repository.go provides:

// Get document by ID
user, err := repo.GetByID(ctx, "507f1f77bcf86cd799439011")

// Find by field
user, err := repo.GetByEmail(ctx, "user@example.com")

// List all documents
users, err := repo.List(ctx)

// Insert document
user, err := repo.Create(ctx, "user@example.com")
```

---

## Example 4: OpenAPI-First Development

```bash
# Create OpenAPI spec
cat > api.yaml << 'EOF'
openapi: 3.0.0
info:
  title: Task API
  version: 1.0.0
paths:
  /api/v1/tasks:
    get:
      summary: List tasks
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Task'
    post:
      summary: Create task
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TaskInput'
      responses:
        '201':
          description: Created
components:
  schemas:
    Task:
      type: object
      properties:
        id:
          type: integer
        title:
          type: string
        completed:
          type: boolean
    TaskInput:
      type: object
      required:
        - title
      properties:
        title:
          type: string
EOF

# Generate project
gocrete init task-api \
  --module github.com/example/task-api \
  --router chi \
  --openapi gen \
  --spec ./api.yaml \
  --db postgres \
  --docker
```

**Generated Structure:**
```
task-api/
├── cmd/server/main.go
├── api/
│   └── openapi.yaml            # Your API specification
├── internal/
│   ├── config/
│   ├── logger/
│   ├── http/
│   ├── errors/
│   ├── db/postgres/
│   └── api/
│       ├── generated/          # Generated from OpenAPI spec
│       │   └── api.gen.go      # Types, interfaces, Chi routes
│       └── handlers/           # Your implementations
│           └── handlers.go
├── Makefile                     # Includes 'make api-gen'
├── docker-compose.yml
├── Dockerfile
└── README.md
```

**Development Workflow:**

1. **Edit OpenAPI Spec:**
   ```bash
   vim api/openapi.yaml
   ```

2. **Regenerate Code:**
   ```bash
   make api-gen
   ```

3. **Implement Handlers:**
   ```go
   // internal/api/handlers/handlers.go
   func (h *Handlers) GetTasks(w http.ResponseWriter, r *http.Request) {
       // Implementation
   }
   ```

4. **Run:**
   ```bash
   docker-compose up
   ```

**Benefits:**
- Contract-first development
- Automatic type generation
- API documentation in code
- Client SDK generation possible

---

## Example 5: Full-Stack Backend

```bash
gocrete init ecommerce-api \
  --module github.com/example/ecommerce-api \
  --router chi \
  --db postgres \
  --openapi gen \
  --spec ./ecommerce-api.yaml \
  --migrations goose \
  --docker
```

**This generates a production-ready backend with:**
- PostgreSQL database with migrations
- OpenAPI code generation
- Docker deployment
- Health checks
- Structured logging
- Request tracing
- Error handling
- Environment configuration

**Project Layout:**
```
ecommerce-api/
├── cmd/server/main.go
├── api/openapi.yaml
├── internal/
│   ├── config/
│   ├── logger/
│   ├── http/
│   ├── errors/
│   ├── db/postgres/
│   └── api/
│       ├── generated/
│       └── handlers/
├── migrations/
├── docker-compose.yml
├── Dockerfile
├── Makefile
└── README.md
```

**Production Deployment:**

1. **Build Image:**
   ```bash
   docker build -t ecommerce-api:latest .
   ```

2. **Run with Docker Compose:**
   ```bash
   docker-compose up -d
   ```

3. **Check Health:**
   ```bash
   curl http://localhost:8080/health
   ```

---

## Example 6: Adding Modules Incrementally

Start simple and add complexity as needed:

```bash
# 1. Start with minimal API
gocrete init my-service --module github.com/me/my-service

cd my-service

# 2. Add PostgreSQL later
gocrete add db --type postgres

# 3. Add Docker when ready for deployment
gocrete add docker

# 4. Add OpenAPI for documentation
gocrete add openapi --mode manual
```

**This approach allows:**
- Start lean, add features when needed
- Test incrementally
- Learn the structure before adding complexity
- Avoid overwhelming initial setup

---

## Common Patterns

### Pattern 1: REST API with CRUD

**Best Setup:**
```bash
gocrete init my-crud-api \
  --module github.com/me/my-crud-api \
  --router chi \
  --db postgres \
  --migrations goose \
  --docker
```

**Why:**
- Chi: Standard library-based, great for REST
- PostgreSQL: Battle-tested relational database
- Migrations: Version control for schema
- Docker: Easy local development and deployment

### Pattern 2: High-Performance Microservice

**Best Setup:**
```bash
gocrete init my-microservice \
  --module github.com/me/my-microservice \
  --router fiber \
  --db mongo \
  --docker
```

**Why:**
- Fiber: Extremely fast, low allocation
- MongoDB: Flexible schema, horizontal scaling
- Docker: Container-native deployment

### Pattern 3: Contract-First API

**Best Setup:**
```bash
gocrete init my-contract-api \
  --module github.com/me/my-contract-api \
  --router chi \
  --openapi gen \
  --spec ./api.yaml \
  --docker
```

**Why:**
- OpenAPI gen: Generate types and routes from spec
- Enforces contract adherence
- Auto-generates documentation
- Enables client SDK generation

---

## Next Steps

After generating a project:

1. **Review the code** - Understand the structure
2. **Customize** - Modify for your needs
3. **Add business logic** - Implement your domain
4. **Add tests** - Write unit and integration tests
5. **Configure CI/CD** - Set up GitHub Actions, etc.
6. **Deploy** - Use Docker, Kubernetes, or your platform

## Tips

- Start with minimal features, add more as needed
- Use `--force` to regenerate if you make a mistake
- Docker Compose is great for local development
- Environment variables keep config flexible
- Migrations track database changes over time

## Resources

- [Go Project Layout](https://github.com/golang-standards/project-layout)
- [pgx Documentation](https://pkg.go.dev/github.com/jackc/pgx/v5)
- [MongoDB Go Driver](https://www.mongodb.com/docs/drivers/go/current/)
- [Chi Router](https://github.com/go-chi/chi)
- [OpenAPI Specification](https://swagger.io/specification/)
